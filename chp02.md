<!--title: chp02 -->

# 2章 ハッシュ関数
- ハッシュ関数とセキュリティ特性
- 現在使われるハッシュ関数
- ハッシュの仕組み

「どんなものにも、全体の中で重複しない識別情報を結びつける」ことがハッシュ関数の仕事。
任意の文字列から特定のバイト列を生成する。
入力が同じなら、同じハッシュ列を返す。これが強い。

# 2.1 ハッシュ関数とは何か

アプリのダウンロードとか、パッケージのインストールなどで謎の文字列が生まれる。

たとえば `sha256sum`とか見たことありそう。これはどのように処理・生成されるのだろうか。

【プロトコル】

- ボタンをクリックしてファイルをダウンロードする
- ダウンロードしたファイルを SHA-256 アルゴリズムでハッシュする
- ハッシュした出力(=ダイジェスト/ハッシュ)を、ウェブページに表示されている文字列と比較する。
    - これが合っている=同じハッシュ値=入力(DLしたファイル)が同じ。

実際にSHA-256を `openssl`でやってみると確かに一致する。  
これをやる目的: ダウンロードしたものが、ダウンロードしようと意図していたファイルに違いないという保証をしたい。

- 完全性(integrity)
- 真正性(authenticity)

ハッシュ関数には「第二現像困難性」がある。
- ハッシュ値が同値になるような「別のファイル」を見つけることは難しい。
- ハッシュ値はウェブページの所有者が管理している
  - ウェブページを書き換えられる人なら、誰でも簡単に差し替えられる点には注意。
  - ダイジェストを提供しているページ、所有者、ページ取得に使われる仕組み
  を信頼する必要がある。
  - 書き換えられる状態だとハッシュ関数だけでは完全性を保証出来ない。

ダウンロードされるファイルの完全性は、ダイジェストと、ダイジェストを提供する仕組み(httpsなど)

- ハッシュ関数の入力: 何でもいい。空白ですらいい。
- ハッシュ関数の出力: 決定論的に「同じ長さ」になる(SHA-256は256ビット)
  - 16進数の数字列64個で表現される。
  - 一文字かわるだけで全部違う。

# 2.2 ハッシュ関数のセキュリティ特性

### 現像計算困難性
- ある出力が与えられるとき、ハッシュ関数を逆に計算して入力を求めることはできない
  - ミキサーみたいなもん。一回キャベツぶっこんだら終わり。
    
    > 入力が小さい場合、たとえば入力が3文字しかない場合は総当たりで試せちゃう。
    また、入力の差が小さい場合。「月曜日の午前3時に帰宅する」について、たとえば
    「月曜の15時に帰宅する」とか「月曜午後3時に帰宅する」など、色々試せるとすると、
    正確な入力が得られるかもしれない。
    > 
    
    正直現像計算困難性は完全に達成することは難しい
    
### 第二現像計算困難性
- ある入力とダイジェストがあるとき、ハッシュして同じダイジェストになるような
「別の入力」を求めることが出来ない。
- 現像計算困難性を補う特性。
- 最初の入力は何もコントロールしていない。
    - 攻撃者はファイル管理者の持つダイジェストと同じハッシュ値を持つファイルに
    悪意を仕込んで差し替えるような動きが想定できる

### 衝突困難性（衝突計算困難性/衝突耐性）
- ハッシュして同じ値になるような2種類の入力は存在しない
- 衝突困難性では、攻撃者が入力をコントロールする。
  - つまり、同じハッシュ値を持つ2つのファイルを用意して、  
  一方に善意、もう一方で悪意を仕込んで、悪意をDLさせる動きができる
    
    > 考えてみよう  
    > 衝突困難性と第二現像計算困難性の違いは何だろう？  
    > → 攻撃者が2つの入力を選ぶことができる点。

### ランダムオラクル

ハッシュ関数は一般的に、予測不能でランダムなダイジェストを出力するように設計される。
ハッシュ関数のセキュリティ特性上、プロトコルが安全であると永続的に保証できないので、
ランダムで予測不能に設計する必要がある。
「ランダムオラクル」は架空の構造を想定したモデル。プロトコルはこれを使って安全性を保証する。
ランダムオラクルを使った安全性保証のプロトコルでは、任意の入力を送信すると、ランダムオラクルから  
全くランダムな出力が返される。  
ただし、ランダムオラクルが、現実的にハッシュ関数に置き換えることができるかは不確実。  
でも実際ランダムオラクルによるプロトコル保証は行われているし、ハッシュ関数は理想的なものっぽい。  

# 2.3 ハッシュ関数のセキュリティに関する考察
ハッシュ関数のセキュリティ特性は以下の3つ
- 現像計算困難性
- 第二現像計算困難性
- 衝突困難性

ハッシュ関数のセキュリティ特性の「意味」は、ハッシュ関数をどう使うかによって決まる。  
ただし、ハッシュ関数の限界も存在する。  

上記3つのセキュリティ特性は、ハッシュ関数が合理的に使われていることが前提にある。
特に第二現像計算困難性は、あくまで「とても難しい」「現実的に達成できない」という意味で、  
理論上はめちゃくちゃ頑張れば出来てしまう、ということ。

### 例: 「はい」と「いいえ」のハッシュ化
Aliceが「はい」と「いいえ」のどちらかをハッシュ化して、そのダイジェスト(ハッシュ値)を公開する。  
もしBobが「ハッシュ化されているのは『はい』か『いいえ』である」ことを知っていたら、  
こちらでハッシュ化して、そのダイジェストを比較すれば、Aliceが何をハッシュ化したのかがわかる。  
この場合、AliceとBobとの間に「秘密」はどこにもなくなる。

現像計算困難性を満たさないかもしれないが、ハッシュ関数を利用する際の「ランダム度」が足りなかったという反論も可能。たまたま別の言葉で同じハッシュ値が出てきたとしたら、第二現像計算困難性を破ることになる。

### ダイジェストのサイズ
これはハッシュ関数に限った話ではなく、暗号アルゴリズム一般に言えること。  
ハッシュ関数は、現代では最低256ビットの値を返すように決まっている。  
具体的には以下の条件が「最低条件」となっている。

- 対衝突困難性には256ビット
- 現像計算困難性、第二現像計算困難性には128ビット
  
この大きさはよほどの計算能力を持つコンピュータが出てこなければ覆らない。

ハッシュ関数から離れると、現代暗号は最低128ビットのセキュリティ($2^{128}$の計算を実施する)を目指す  
ハッシュ関数が現像計算困難性、第二現像計算困難性、衝突困難性の3つを満たすには、それぞれに対して$2^{128}$のセキュリティを求める。  
誕生日限界を考えると、$2^{128}$のセキュリティを達成するには、$2^{256}$のランダムな出力ができるように  
設計されなければならない。

#### 誕生日限界
1つの部屋に何人いたら、そのうち2人が同じ誕生日だろうか？というお話。  
現実上レアな確率かなと思いがちだが、実際は23人いると、50%の確率で  
誕生日がダブる。  

$2^N$通りの組合せから文字列をランダムに生成する場合、特定の文字列と一致するような文字列を生成するには、  
$2^{N/2}$の確率で衝突を見つけることができる

#### 例: 2ビットのハッシュ値を返すハッシュ関数
2ビットのハッシュ値を返すハッシュ関数は、その返り値が以下の4つ。

- 00
- 01
- 10
- 11

適当な文字列でも、多分上記のどれかに変換されるので、現像ができる。  

# 2.4 現実世界でのハッシュ関数

現実世界では、ハッシュ関数単体で使われることはない。  
ハッシュ関数と他の機能を組合せて暗号プリミティブ/暗号プロトコルが構築している。  
## 2.4.1 コミットメント
- 「X社の株が値上がりした！6,000円になる！」ということが分かった。  
  - でも法律的にまずいので友人には教えられない。
  - でも「事前に知っていた」ということは自慢したい。  
- 「X社の株は1ヶ月後に6,000円になる」という文を「宣言(Commitment)」しておけば良い。
  - この文をハッシュ化して友人に預け、1ヶ月後にその文を公開する。  
  - 同じ文章がハッシュされれているとすれば、友人も信じてくれる。

上記の使われ方を「コミットメント方式」と呼ぶ。  
コミットメント方式で達成したい目的
1. 秘匿性: コミットメントは元の文(平文)を隠さなければならない
2. 拘束性: コミットメントは1つの値だけを隠すものでなければならない。
   - たとえば文$x$をコミットしたら、別の値$y$が出てきてはいけない

### 演習
- コミットメント方式にハッシュ関数を使ったとき、秘匿性と拘束性は保証されるか？
  - 秘匿性は保証されるかもしれない。
  - 拘束性は微妙。現像計算困難性と衝突困難性を完全に達成することが難しいので。

## 2.4.2 サブリソース完全性

## 2.4.3 BitTorrent

## 2.4.4 Tor

# 2.5 標準化されたハッシュ関数

## 2.5.1 SHA-2ハッシュ関数

## 2.5.2 SHA-3ハッシュ関数

## 2.5.3 SHAKEとcSHAKE: 2つの可変長出力関数(XOF)

## 2.5.4 TupleHashによるハッシュで曖昧さを回避する

# 2.6 パスワードのハッシュ