<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>chp02</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="chp02_files/libs/clipboard/clipboard.min.js"></script>
<script src="chp02_files/libs/quarto-html/quarto.js"></script>
<script src="chp02_files/libs/quarto-html/popper.min.js"></script>
<script src="chp02_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="chp02_files/libs/quarto-html/anchor.min.js"></script>
<link href="chp02_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="chp02_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="chp02_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="chp02_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="chp02_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<!--title: chp02 -->
<p><a href="https://8-u8.github.io/Real_World_Cryptography/">TOPへ戻る</a></p>
<section id="章-ハッシュ関数" class="level1">
<h1>2章 ハッシュ関数</h1>
<ul>
<li>ハッシュ関数とセキュリティ特性</li>
<li>現在使われるハッシュ関数</li>
<li>ハッシュの仕組み</li>
</ul>
<p>「どんなものにも、全体の中で重複しない識別情報を結びつける」ことがハッシュ関数の仕事。 任意の文字列から特定のバイト列を生成する。 入力が同じなら、同じハッシュ列を返す。これが強い。</p>
</section>
<section id="ハッシュ関数とは何か" class="level1">
<h1>2.1 ハッシュ関数とは何か</h1>
<p>アプリのダウンロードとか、パッケージのインストールなどで謎の文字列が生まれる。</p>
<p>たとえば <code>sha256sum</code>とか見たことありそう。これはどのように処理・生成されるのだろうか。</p>
<p>【プロトコル】</p>
<ul>
<li>ボタンをクリックしてファイルをダウンロードする</li>
<li>ダウンロードしたファイルを SHA-256 アルゴリズムでハッシュする</li>
<li>ハッシュした出力(=ダイジェスト/ハッシュ)を、ウェブページに表示されている文字列と比較する。
<ul>
<li>これが合っている=同じハッシュ値=入力(DLしたファイル)が同じ。</li>
</ul></li>
</ul>
<p>実際にSHA-256を <code>openssl</code>でやってみると確かに一致する。<br>
これをやる目的: ダウンロードしたものが、ダウンロードしようと意図していたファイルに違いないという保証をしたい。</p>
<ul>
<li>完全性(integrity)</li>
<li>真正性(authenticity)</li>
</ul>
<p>ハッシュ関数には「第二現像困難性」がある。 - ハッシュ値が同値になるような「別のファイル」を見つけることは難しい。 - ハッシュ値はウェブページの所有者が管理している - ウェブページを書き換えられる人なら、誰でも簡単に差し替えられる点には注意。 - ダイジェストを提供しているページ、所有者、ページ取得に使われる仕組み を信頼する必要がある。 - 書き換えられる状態だとハッシュ関数だけでは完全性を保証出来ない。</p>
<p>ダウンロードされるファイルの完全性は、ダイジェストと、ダイジェストを提供する仕組み(httpsなど)</p>
<ul>
<li>ハッシュ関数の入力: 何でもいい。空白ですらいい。</li>
<li>ハッシュ関数の出力: 決定論的に「同じ長さ」になる(SHA-256は256ビット)
<ul>
<li>16進数の数字列64個で表現される。</li>
<li>一文字かわるだけで全部違う。</li>
</ul></li>
</ul>
</section>
<section id="ハッシュ関数のセキュリティ特性" class="level1">
<h1>2.2 ハッシュ関数のセキュリティ特性</h1>
<section id="現像計算困難性" class="level3">
<h3 class="anchored" data-anchor-id="現像計算困難性">現像計算困難性</h3>
<ul>
<li>ある出力が与えられるとき、ハッシュ関数を逆に計算して入力を求めることはできない
<ul>
<li><p>ミキサーみたいなもん。一回キャベツぶっこんだら終わり。</p>
<blockquote class="blockquote">
<p>入力が小さい場合、たとえば入力が3文字しかない場合は総当たりで試せちゃう。 また、入力の差が小さい場合。「月曜日の午前3時に帰宅する」について、たとえば 「月曜の15時に帰宅する」とか「月曜午後3時に帰宅する」など、色々試せるとすると、 正確な入力が得られるかもしれない。</p>
</blockquote>
<p>正直現像計算困難性は完全に達成することは難しい</p></li>
</ul></li>
</ul>
</section>
<section id="第二現像計算困難性" class="level3">
<h3 class="anchored" data-anchor-id="第二現像計算困難性">第二現像計算困難性</h3>
<ul>
<li>ある入力とダイジェストがあるとき、ハッシュして同じダイジェストになるような 「別の入力」を求めることが出来ない。</li>
<li>現像計算困難性を補う特性。</li>
<li>最初の入力は何もコントロールしていない。
<ul>
<li>攻撃者はファイル管理者の持つダイジェストと同じハッシュ値を持つファイルに 悪意を仕込んで差し替えるような動きが想定できる</li>
</ul></li>
</ul>
</section>
<section id="衝突困難性衝突計算困難性衝突耐性" class="level3">
<h3 class="anchored" data-anchor-id="衝突困難性衝突計算困難性衝突耐性">衝突困難性（衝突計算困難性/衝突耐性）</h3>
<ul>
<li>ハッシュして同じ値になるような2種類の入力は存在しない</li>
<li>衝突困難性では、攻撃者が入力をコントロールする。
<ul>
<li><p>つまり、同じハッシュ値を持つ2つのファイルを用意して、<br>
一方に善意、もう一方で悪意を仕込んで、悪意をDLさせる動きができる</p>
<blockquote class="blockquote">
<p>考えてみよう<br>
衝突困難性と第二現像計算困難性の違いは何だろう？<br>
→ 攻撃者が2つの入力を選ぶことができる点。</p>
</blockquote></li>
</ul></li>
</ul>
</section>
<section id="ランダムオラクル" class="level3">
<h3 class="anchored" data-anchor-id="ランダムオラクル">ランダムオラクル</h3>
<p>ハッシュ関数は一般的に、予測不能でランダムなダイジェストを出力するように設計される。 ハッシュ関数のセキュリティ特性上、プロトコルが安全であると永続的に保証できないので、 ランダムで予測不能に設計する必要がある。 「ランダムオラクル」は架空の構造を想定したモデル。プロトコルはこれを使って安全性を保証する。 ランダムオラクルを使った安全性保証のプロトコルでは、任意の入力を送信すると、ランダムオラクルから<br>
全くランダムな出力が返される。<br>
ただし、ランダムオラクルが、現実的にハッシュ関数に置き換えることができるかは不確実。<br>
でも実際ランダムオラクルによるプロトコル保証は行われているし、ハッシュ関数は理想的なものっぽい。</p>
</section>
</section>
<section id="ハッシュ関数のセキュリティに関する考察" class="level1">
<h1>2.3 ハッシュ関数のセキュリティに関する考察</h1>
<p>ハッシュ関数のセキュリティ特性は以下の3つ - 現像計算困難性 - 第二現像計算困難性 - 衝突困難性</p>
<p>ハッシュ関数のセキュリティ特性の「意味」は、ハッシュ関数をどう使うかによって決まる。<br>
ただし、ハッシュ関数の限界も存在する。</p>
<p>上記3つのセキュリティ特性は、ハッシュ関数が合理的に使われていることが前提にある。 特に第二現像計算困難性は、あくまで「とても難しい」「現実的に達成できない」という意味で、<br>
理論上はめちゃくちゃ頑張れば出来てしまう、ということ。</p>
<section id="例-はいといいえのハッシュ化" class="level3">
<h3 class="anchored" data-anchor-id="例-はいといいえのハッシュ化">例: 「はい」と「いいえ」のハッシュ化</h3>
<p>Aliceが「はい」と「いいえ」のどちらかをハッシュ化して、そのダイジェスト(ハッシュ値)を公開する。<br>
もしBobが「ハッシュ化されているのは『はい』か『いいえ』である」ことを知っていたら、<br>
こちらでハッシュ化して、そのダイジェストを比較すれば、Aliceが何をハッシュ化したのかがわかる。<br>
この場合、AliceとBobとの間に「秘密」はどこにもなくなる。</p>
<p>現像計算困難性を満たさないかもしれないが、ハッシュ関数を利用する際の「ランダム度」が足りなかったという反論も可能。たまたま別の言葉で同じハッシュ値が出てきたとしたら、第二現像計算困難性を破ることになる。</p>
</section>
<section id="ダイジェストのサイズ" class="level3">
<h3 class="anchored" data-anchor-id="ダイジェストのサイズ">ダイジェストのサイズ</h3>
<p>これはハッシュ関数に限った話ではなく、暗号アルゴリズム一般に言えること。<br>
ハッシュ関数は、現代では最低256ビットの値を返すように決まっている。<br>
具体的には以下の条件が「最低条件」となっている。</p>
<ul>
<li>対衝突困難性には256ビット</li>
<li>現像計算困難性、第二現像計算困難性には128ビット</li>
</ul>
<p>この大きさはよほどの計算能力を持つコンピュータが出てこなければ覆らない。</p>
<p>ハッシュ関数から離れると、現代暗号は最低128ビットのセキュリティ(<span class="math inline">\(2^{128}\)</span>の計算を実施する)を目指す<br>
ハッシュ関数が現像計算困難性、第二現像計算困難性、衝突困難性の3つを満たすには、それぞれに対して<span class="math inline">\(2^{128}\)</span>のセキュリティを求める。<br>
誕生日限界を考えると、<span class="math inline">\(2^{128}\)</span>のセキュリティを達成するには、<span class="math inline">\(2^{256}\)</span>のランダムな出力ができるように<br>
設計されなければならない。</p>
<section id="誕生日限界" class="level4">
<h4 class="anchored" data-anchor-id="誕生日限界">誕生日限界</h4>
<p>1つの部屋に何人いたら、そのうち2人が同じ誕生日だろうか？というお話。<br>
現実上レアな確率かなと思いがちだが、実際は23人いると、50%の確率で<br>
誕生日がダブる。</p>
<p><span class="math inline">\(2^N\)</span>通りの組合せから文字列をランダムに生成する場合、特定の文字列と一致するような文字列を生成するには、<br>
<span class="math inline">\(2^{N/2}\)</span>の確率で衝突を見つけることができる</p>
</section>
<section id="例-2ビットのハッシュ値を返すハッシュ関数" class="level4">
<h4 class="anchored" data-anchor-id="例-2ビットのハッシュ値を返すハッシュ関数">例: 2ビットのハッシュ値を返すハッシュ関数</h4>
<p>2ビットのハッシュ値を返すハッシュ関数は、その返り値が以下の4つ。</p>
<ul>
<li>00</li>
<li>01</li>
<li>10</li>
<li>11</li>
</ul>
<p>適当な文字列でも、多分上記のどれかに変換されるので、現像ができる。</p>
</section>
</section>
</section>
<section id="現実世界でのハッシュ関数" class="level1">
<h1>2.4 現実世界でのハッシュ関数</h1>
<p>現実世界では、ハッシュ関数単体で使われることはない。<br>
ハッシュ関数と他の機能を組合せて暗号プリミティブ/暗号プロトコルが構築している。</p>
<section id="コミットメント" class="level2">
<h2 class="anchored" data-anchor-id="コミットメント">2.4.1 コミットメント</h2>
<ul>
<li>「X社の株が値上がりした！6,000円になる！」ということが分かった。
<ul>
<li>でも法律的にまずいので友人には教えられない。</li>
<li>でも「事前に知っていた」ということは自慢したい。<br>
</li>
</ul></li>
<li>「X社の株は1ヶ月後に6,000円になる」という文を「宣言(Commitment)」しておけば良い。
<ul>
<li>この文をハッシュ化して友人に預け、1ヶ月後にその文を公開する。<br>
</li>
<li>同じ文章がハッシュされれているとすれば、友人も信じてくれる。</li>
</ul></li>
</ul>
<p>上記の使われ方を「コミットメント方式」と呼ぶ。<br>
コミットメント方式で達成したい目的</p>
<ol type="1">
<li>秘匿性: コミットメントは元の文(平文)を隠さなければならない</li>
<li>拘束性: コミットメントは1つの値だけを隠すものでなければならない。
<ul>
<li>たとえば文<span class="math inline">\(x\)</span>をコミットしたら、別の値<span class="math inline">\(y\)</span>が出てきてはいけない</li>
</ul></li>
</ol>
<section id="演習" class="level3">
<h3 class="anchored" data-anchor-id="演習">演習</h3>
<ul>
<li>コミットメント方式にハッシュ関数を使ったとき、秘匿性と拘束性は保証されるか？
<ul>
<li>秘匿性は保証されるかもしれない。</li>
<li>拘束性は微妙。現像計算困難性と衝突困難性を完全に達成することが難しいので。</li>
</ul></li>
</ul>
</section>
</section>
<section id="サブリソース完全性" class="level2">
<h2 class="anchored" data-anchor-id="サブリソース完全性">2.4.2 サブリソース完全性</h2>
<ul>
<li>Webページは、外部のJavascriptをインポートしていることが多い
<ul>
<li>コンテンツデリバリーネットワーク(CDN)を使ってJavascriptライブラリ・ Webフレームワーク関連のファイルをページに読み込む。</li>
</ul></li>
<li>CDNが不正に利用されて、悪意のあるJavascriptファイルを配信すると、大変。</li>
<li>ウェブページはサブリソース完全性という性質をもっている
<ul>
<li>以下のように、インポートタグを使ってダイジェストを指定する。</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript code-with-copy"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>script src<span class="op">=</span><span class="st">"https://code.jquery.com/jquery-2.1.4.min.js"</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>integrity<span class="op">=</span><span class="st">"sha256-8WqyJLuWKRBVhxXIL1jBDD7SDxU936ozCnxQbWwJVw="</span><span class="op">&gt;&lt;/</span>script<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li>Javascriptファイルを取得すると、Sha-256を利用してファイルをハッシュして、ページにハードコード(別の所で指定・処理するべき内容をソースコードに直接書き込むこと)されているダイジェストに対応するかを検証する。</li>
</ul>
</section>
<section id="bittorrent" class="level2">
<h2 class="anchored" data-anchor-id="bittorrent">2.4.3 BitTorrent</h2>
<ul>
<li>世界中のユーザ(ピア)が相互に直接ファイルを共有できる(ピアツーピア)プロトコル。</li>
<li>共有したいファイルを「チャンク」に分割し、チャンクごとにハッシュ化する。
<ul>
<li>このハッシュがダウンロードするファイルを表すファイルを表す「信頼できるソース」として共有される</li>
</ul></li>
<li>ピアが他のピアから様々なファイルのチャンクを取得する仕組みがある
<ul>
<li>ダウンロードした各チャンクをハッシュして、その出力を、すでにわかっているダイジェストたちと比較することで、ファイル全体の完全性を検証する
<ul>
<li>ここで、ファイル全体を再構成する前に行う。つまり分割した状態での検証が行われている。</li>
</ul></li>
</ul></li>
<li>以下はUbuntu 19.04のマグネットリンク。
<ul>
<li>マグネットリンクは、ファイル共有のためのリンク。</li>
<li>ファイルに対するメタデータと、チャンクのダイジェストすべてをハッシュして得られたダイジェスト</li>
</ul></li>
</ul>
<pre class="shell"><code>magnet:?xt=urn:btih:b7b0fbab74a85d4ac170662c645982a862826455</code></pre>
</section>
<section id="torトーア" class="level2">
<h2 class="anchored" data-anchor-id="torトーア">2.4.4 Tor(トーア)</h2>
<ul>
<li>ブラウザ。
<ul>
<li>個人が匿名でインターネットを閲覧できるようにすることを目的にしている。</li>
<li>応用で、物理的な所在地を追跡しにくい隠れたウェブページを作成する機能もある。</li>
</ul></li>
<li>Torで作成したページは、ウェブページの公開鍵を使用するプロトコルで保護される→9章</li>
<li>「麻薬のeBay」と呼ばれたSilk Roadというサイト
<ul>
<li>Torブラウザでアクセスできるonionアドレス(base32)が、Silk Roadの公開鍵のハッシュだった。</li>
<li>onionアドレスを知っていれば、アクセスしている隠れウェブページの公開鍵を認証して、アクセス先が正しいページである、つまり「なりすましではない」ことを確認できるというもの</li>
</ul></li>
</ul>
<section id="演習-1" class="level3">
<h3 class="anchored" data-anchor-id="演習-1">演習</h3>
<p>onionアドレスは256ビットではないので、2.3節で考えた内容をそのまま使うにはセキュリティに対応していない。<br>
ではどう保つのか？</p>
<ul>
<li>えー、どう保つんだ。</li>
</ul>
</section>
</section>
</section>
<section id="標準化されたハッシュ関数" class="level1">
<h1>2.5 標準化されたハッシュ関数</h1>
<p>SHA-256は普及しているハッシュ関数のうちの1つ。<br>
暗号学的ハッシュ関数(暗号としての用途に耐えうる強度を持つハッシュ関数)としてみなされていないが、<br>
(なぜか)現実世界で使われている関数について見てみる。</p>
<ol type="1">
<li>CRC32
<ul>
<li>誤り検出符号の関数であり、暗号学的ハッシュ関数ではない
<ul>
<li><a href="https://e-words.jp/w/%E8%AA%A4%E3%82%8A%E6%A4%9C%E5%87%BA%E7%AC%A6%E5%8F%B7.html#:~:text=%E8%AA%A4%E3%82%8A%E6%A4%9C%E5%87%BA%E7%AC%A6%E5%8F%B7%E3%80%90EDC%E3%80%91Error,%E3%83%87%E3%83%BC%E3%82%BF%E3%81%A8%E5%85%B1%E3%81%AB%E8%A8%98%E9%8C%B2%E3%83%BB%E4%BC%9D%E9%80%81%E3%81%99%E3%82%8B%E3%80%82">IT用語辞典</a>によれば、「データを記録・伝送する際に発生する誤りを受け手の側で検出できるように付加される符号」らしい。</li>
<li>データの通信では、ノイズなどの様々な理由でデータの欠落や改変が起こりうる。</li>
<li>これを防止することは不可能だが、検出はできるので、検出して対処するらしい。</li>
</ul></li>
<li>現像計算困難性、第二現像計算困難性、衝突困難性のいずれも満たしていない。</li>
<li>チェックサムとも呼ばれる</li>
</ul></li>
<li>MD5/SHA-1
<ul>
<li>すでに脆弱性(衝突困難性)が生まれ、攻撃可能であることが示されている。</li>
<li>コンピュータの処理性能が上がったことも理由になるが、基本的には設計ミスでもある。</li>
<li>MD5はRのパッケージインストールでのチェックサムでも行われている。
<ul>
<li>たとえば<a href="https://bugs.r-project.org/show_bug.cgi?id=18288#c12">ここ</a>での議論はまさに「チェックサムとインストールされたパッケージの中身の改ざんの可能性の違い」に関する議論</li>
</ul></li>
</ul></li>
</ol>
<section id="標準の廃止は難しい" class="level3">
<h3 class="anchored" data-anchor-id="標準の廃止は難しい">標準の廃止は難しい</h3>
<p>MD5やSHA1は、現像計算困難性に依存したシステムでは未だに使われる。<br>
なぜならば、現像計算困難性と第二現像困難性は、MD5/SHA-1ではまだ破られていないため。<br>
つまり、ハッシュ値からもとの値を計算したり。、同じダイジェストを返すような別の入力を<br>
見つけだしたりすることは難しい。<br>
運用上、レガシーなシステムだったり、後方互換性が必要だったりで、これらを廃止することは難しい。</p>
</section>
<section id="排他的論理和" class="level3">
<h3 class="anchored" data-anchor-id="排他的論理和">排他的論理和</h3>
<p>2つのビットがあるとき、その排他的論理和を <span class="math inline">\(bit_A \oplus bit_B\)</span>で表す。<br>
このとき、演算結果は以下のようになる。</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(bit_A\)</span></th>
<th style="text-align: center;"><span class="math inline">\(bit_B\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\oplus\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>暗号の計算でめちゃくちゃ使われるので、覚えてくれとのこと。 <a href="https://xorio.makeaji.games/">これを勉強するためのゲームがあるよ</a></p>
</section>
<section id="sha-2ハッシュ関数" class="level2">
<h2 class="anchored" data-anchor-id="sha-2ハッシュ関数">2.5.1 SHA-2ハッシュ関数</h2>
<section id="マークルダンガード構成法" class="level3">
<h3 class="anchored" data-anchor-id="マークルダンガード構成法">マークル/ダンガード構成法</h3>
<ul>
<li>とりあえず日本語ですぐわかるような記事はなかったので<a href="https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction">英語版Wikipedia</a>をもってきた</li>
</ul>
<p>SHA-2は最も広く使われる暗号学的ハッシュ関数。NSAで開発されて、NISTには2001年に標準化される。<br>
4種類のバージョン(224bits, 256bits, 384bits, 512bits)があり、SHA-224~SHA-512とも記述される。<br>
SHA-512/224とか、SHA-512/256など、SHA-512の値を切り詰めて224ビット、256ビットの値を返すようなものもある。 以下は、実際に<code>hello world</code>という文字列をSHA-2系でハッシュ化した結果。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">┌──</span><span class="er">(</span><span class="ex">kien</span><span class="kw">)</span><span class="ex">-[~]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">└─$</span> echo <span class="at">-n</span> <span class="st">"hello world"</span> <span class="kw">|</span> <span class="ex">openssl</span> dgst <span class="at">-sha224</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ex">SHA2-224</span><span class="er">(</span><span class="ex">stdin</span><span class="kw">)</span><span class="ex">=</span> 2f05477fc24bb4faefd86517156dafdecec45b8ad3cf2522a563582b</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ex">┌──</span><span class="er">(</span><span class="ex">kien</span><span class="kw">)</span><span class="ex">-[~]</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ex">└─$</span> echo <span class="at">-n</span> <span class="st">"hello world"</span> <span class="kw">|</span> <span class="ex">openssl</span> dgst <span class="at">-sha256</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ex">SHA2-256</span><span class="er">(</span><span class="ex">stdin</span><span class="kw">)</span><span class="ex">=</span> b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ex">┌──</span><span class="er">(</span><span class="ex">kien</span><span class="kw">)</span><span class="ex">-[~]</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="ex">└─$</span> echo <span class="at">-n</span> <span class="st">"hello world"</span> <span class="kw">|</span> <span class="ex">openssl</span> dgst <span class="at">-sha384</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ex">SHA2-384</span><span class="er">(</span><span class="ex">stdin</span><span class="kw">)</span><span class="ex">=</span> fdbd8e75a67f29f701a4e040385e2e23986303ea10239211af907fcbb83578b3e417cb71ce646efd0819dd8c088de1bd</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ex">┌──</span><span class="er">(</span><span class="ex">kien</span><span class="kw">)</span><span class="ex">-[~]</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="ex">└─$</span> echo <span class="at">-n</span> <span class="st">"hello world"</span> <span class="kw">|</span> <span class="ex">openssl</span> dgst <span class="at">-sha512</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="ex">SHA2-512</span><span class="er">(</span><span class="ex">stdin</span><span class="kw">)</span><span class="ex">=</span> 309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>現在はSHA-256が使われる。これによって128ビットのセキュリティが確保できる。</p>
</section>
<section id="sha-2の仕組み" class="level3">
<h3 class="anchored" data-anchor-id="sha-2の仕組み">SHA-2の仕組み</h3>
<ol type="1">
<li>圧縮関数(Compression function)
<ul>
<li>同じサイズの2つの入力を取り、一方の入力のサイズの値を出力する。
<ul>
<li>一定のデータを取って小さいデータを返す(図2.7)。</li>
</ul></li>
<li>SHA-2で用いられているのは、ブロック暗号を使った方法
<ul>
<li>デイビーズ・マイヤー法(図2.8)が用いられる。</li>
<li>詳細は4章(認証付き暗号)。今は「そういう関数がある」として飲み込む。</li>
</ul></li>
<li>図2.8の解釈入力①(鍵)と入力②(標準化された固定の値・nothing-up-my-sleeve)を用いて暗号化。
<ul>
<li>入力②との排他的論理和を取ってダイジェストにする</li>
<li>Nothing up my sleeve(私の袖には何もない=袖の下はない=嘘はついていない・切り札はない)
<ul>
<li>SHA-256は最初の方の素数の平方根を使って入力②を計算する。</li>
<li>この値はハッシュ関数を弱体化する(バックドアを作る)ために選択されたわけではないという概念</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<p>デイビーズ/マイヤー法を用いた圧縮関数の図を関数に置き換えておく</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Compression(inputA, inputB):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">'''</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">  inputA: 鍵</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">  inputB: 上記で言うNothing up my sleeve値</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">  '''</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 暗号化する(デイビーズ/マイヤー法)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  code <span class="op">=</span> encrypt(inputA, inputB) <span class="co"># ここの暗号化はとりあえずブラックボックスを許す。</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">hash</span> <span class="op">=</span> code <span class="op">^</span> inputB</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">hash</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>マークル/ダンガード構成法
<ul>
<li>圧縮関数を反復的に呼び出してメッセージをハッシュ化する
<ul>
<li>ハッシュしたい入力をパディング
<ul>
<li>パディング: 一定のブロック長の倍数にあたる長さになるように、<br>
その分のバイトを入力に追加する操作。</li>
<li>パディング後の入力を同じブロックサイズのチャンクに分割すると、<br>
圧縮関数の最初の引数に用いる事ができる。</li>
</ul></li>
</ul></li>
<li>ブロックになった入力メッセージに圧縮関数を反復的に適用する
<ul>
<li>1つ前の圧縮関数の出力が、次の圧縮関数の入力の1つになる。</li>
<li>最後の出力がハッシュ値のダイジェスト。</li>
</ul></li>
</ul></li>
</ol>
<p>コードのイメージを書いておく</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> MerkleDamgard(inputA, inputB):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">'''</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">  inputA: 鍵のリスト</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">  inputB: 上記で言うNothing up my sleeve値</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">  '''</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 暗号化する</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> inputA: <span class="co"># ここは謎。</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>      digest <span class="op">=</span> Compression(inputA[i], inputB)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>      digest <span class="op">=</span> Compression(inputA[i], digest)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> digest</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sha-2の適用範囲" class="level3">
<h3 class="anchored" data-anchor-id="sha-2の適用範囲">SHA-2の適用範囲</h3>
<p>ハッシュ関数として用いること自体に問題はないが、秘密のハッシュ化そのものには向いていない。 SHA-2は、伸長攻撃に脆弱(3章までお楽しみ)</p>
</section>
<section id="マークルダンガード構成法の保証" class="level3">
<h3 class="anchored" data-anchor-id="マークルダンガード構成法の保証">マークル/ダンガード構成法の保証</h3>
<p>衝突困難性が保証される条件は、圧縮関数そのものが衝突困難性を備えていることがある。<br>
任意の長さの入力に対するハッシュ関数のセキュリティは、固定サイズの圧縮関数の長さに依存する。<br>
この依存が、設計と解析の容易さを生み出し、マークル/ダンガード構成法の(どういう意味での？)「有利」さをもたらしている</p>
</section>
</section>
<section id="sha-3ハッシュ関数" class="level2">
<h2 class="anchored" data-anchor-id="sha-3ハッシュ関数">2.5.2 SHA-3ハッシュ関数</h2>
<section id="スポンジ構造" class="level3">
<h3 class="anchored" data-anchor-id="スポンジ構造">スポンジ構造</h3>
<ul>
<li>これはどうやら基本的事項らしいので<a href="https://ja.wikipedia.org/wiki/SHA-3">日本語版Wikipedia</a>にも記述がある</li>
</ul>
<p>SHA-2が伸長攻撃に対して脆弱であるということがわかっているので、NISTは2007年にSHA-3の制定のためのコンペを開催する。Keccakが2012年に優勝し、FIPS PUB 202として標準化された。</p>
<p>参考: <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">NISTのPablish</a></p>
</section>
<section id="sha-3の特徴" class="level3">
<h3 class="anchored" data-anchor-id="sha-3の特徴">SHA-3の特徴</h3>
<ul>
<li>現像計算困難性、第2現像計算困難性、衝突困難性のすべてを満たす。</li>
<li>SHA-2と同じ程度のセキュリティ(128ビット以上)のセキュリティを保証する</li>
<li>伸長攻撃に対しても頑健である</li>
</ul>
<p>現時点で推奨されるハッシュ関数として用いられている。</p>
</section>
<section id="考え方のベース-転置並べ替えとスポンジ構造" class="level3">
<h3 class="anchored" data-anchor-id="考え方のベース-転置並べ替えとスポンジ構造">考え方のベース: 転置・並べ替えとスポンジ構造</h3>
<section id="転置permutation-並び替え" class="level4">
<h4 class="anchored" data-anchor-id="転置permutation-並び替え">転置(Permutation: 並び替え)</h4>
<p>図2.11をよく見て。以下は77ページの引用</p>
<blockquote class="blockquote">
<p>矢印の始点でも終点でも、要素はそれぞれ1つずつに限定されることとする。</p>
</blockquote>
<p>これは一対一対応・全単射の考えが近いかなと思う。<br>
たとえば○→△だったり、△→□だったりする変換が行われる。<br>
一対一対応であれば良いので、★→★のように、変換後の値が同じでも構わない。</p>
<p><code>keccak-f</code>という転置設計がベースとなってスポンジ構造をもったSHA-3アルゴリズムをもっている。</p>
</section>
<section id="ビットでのスポンジ構造" class="level4">
<h4 class="anchored" data-anchor-id="ビットでのスポンジ構造">8ビットでのスポンジ構造</h4>
<p>Pythonの想像をすると、0か1をとる長さ8のリストを考えれば良さそう。<br>
たとえば以下は、図2.12をコード化したもの。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>] </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span>f(x) <span class="co">#転置関数。</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>y</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># これが2^8 = 256通りの変換が得られる</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>スポンジ構造で転置を用いるときには、入力と出力に区切りを用いる。 レート(rate)とキャパシティ(capacity)と呼ばれる。<br>
キャパシティは秘密のように扱われるので、大きいほど良さそう。</p>
<p>以下は図2.13をコードに落とし込んだもの。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>rate <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [rate, capacity]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]] <span class="co"># 上の例を、明示的に示している。</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, v <span class="kw">in</span> <span class="bu">enumerate</span>(x):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  y[i] <span class="op">=</span> f(v)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>y</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>この関数がハッシュ関数として正しく機能するためには、ハッシュのための演算を組み込む必要がある。 転置の入力のrate部分のXORを求める。rateの初期状態は0のみのリストになり、<br>
キャパシティ部分はXORを求めなくても良い。</p>
<p>図2.14を考える。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>val <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>] <span class="co"># 「吸収」したいビット列</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [rate, capacity]  <span class="co"># [0, 0, 0, 0, 0]のビット列</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> []</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, v <span class="kw">in</span> <span class="bu">enumerate</span>(x[<span class="dv">0</span>]):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  t <span class="op">=</span> v <span class="op">^</span> val[j] <span class="co"># すべて0のビット列とXORを取れば入力がそのまま返る</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  z.append(t)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>z</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>x_hash <span class="op">=</span> [z, capacity]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> f(x_hash) <span class="co"># 転置の実行。これによってビットの状態はランダム化する。</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>y </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span>[[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>転置によって得られた結果はランダムになっているはずらしい。なぜそうなのかはわからない。<br>
ただ、転置は定義を考えると一対一対応の写像であるから、入力が何かを考えることはできる。<br>
吸収する入力が大きいときは次の手順を踏む。</p>
<ol type="1">
<li>必要に応じて入力をパディングして、入力をレートのサイズに合わせたブロックに分割する</li>
<li>各ブロックと転置入力とのXORを求め、各ブロックのXOR後に中間値を使って反復的に<br>
転置を実行する。</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">レートのサイズ(ここでは5)よりも大きな入力を吸収する場合、</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">スポンジ構造は入力のブロックとレートとのXORを反復して求めていき、</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">その結果を転置する。</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>] <span class="co"># 長いビット列</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>inputs_sep <span class="op">=</span> [[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>]] <span class="co"># 5ビットずつに分割(rateと同じ長さ)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>rate <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> []</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, x <span class="kw">in</span> <span class="bu">enumerate</span>(inputs_sep):</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> idx <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> rate</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  tmp_y <span class="op">=</span> x</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i, v <span class="kw">in</span> <span class="bu">enumerate</span>(tmp_y):</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> v <span class="op">^</span> z[i] <span class="co"># XORを実行する</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  tmp_x <span class="op">=</span> [t, capacity]</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  z <span class="op">=</span> f(tmp_x) <span class="co"># 転置を実行する。次の入力になる。</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>z </span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ダイジェストを生成するにはスポンジの最終的な状態のレートを使えば良い。<br>
ダイジェストが長くなる場合は転置を続けながら状態のレート部分を読み取る。</p>
<blockquote class="blockquote">
<p>2.16: スポンジ構造でダイジェストを取得するには 反復的に状態を転置していきながら、必要なだけのレートを取得する。</p>
</blockquote>
<p>入力を取り込むことを「吸収」、ダイジェストを生成する過程を「搾出」という。<br>
※ 搾り出す、ということだね。</p>
<p>スポンジに指定される転置関数は1600ビット。</p>
</section>
</section>
<section id="sha-3はランダムオラクル" class="level3">
<h3 class="anchored" data-anchor-id="sha-3はランダムオラクル">SHA-3はランダムオラクル</h3>
<p>ランダムオラクルは入力に関して完全にランダムな出力を返して、<br>
同じ入力であれば同じ値を返す仮想的・理論的なデータ構造。<br>
スポンジ構造は、転置関数が十分にランダムである限り、<br>
ランダムオラクルに「近い」動作をすることがわかっている。<br>
セキュリティ特性の証明は「信頼できるまで突破を試みる」という<br>
強引な方法が取られる。</p>
</section>
</section>
<section id="shakeとcshake-2つの可変長出力関数xof" class="level2">
<h2 class="anchored" data-anchor-id="shakeとcshake-2つの可変長出力関数xof">2.5.3 SHAKEとcSHAKE: 2つの可変長出力関数(XOF)</h2>
<p>SHA-2とSHA-3は、任意の長さの入力から、ランダムに見える固定長の出力を返す。<br>
一方で、ハッシュ関数のダイジェストが固定長であるという性質が望ましくない場合もあるらしい。 eXtendable Output Function(XOF)という汎用性の高いプリミティブがSHA-3には採用されている。</p>
<ul>
<li>SHAKEはFIPS202で標準化されていて、任意の長さの出力を返すハッシュ関数と考えて差し支えない。</li>
<li>SHA-3と同じ構成法だがより高速で、搾出フェイズでいくらでも転置関数を使える。</li>
<li>長さの違う出力の生成では、乱数の生成や鍵の取得などに応用でき、どうやら便利らしい。</li>
</ul>
<p>cSHAKEはカスタマイズ文字列も取れるSHAKE。2つのダイジェストが同じにはならない(カスタマイズ文字列によって演算が変わるため)。<br>
これは、証明を成立させるために異なるハッシュ関数を使用する必要があるプロトコルで重要。<br>
- ドメイン分離と呼ぶ。</p>
<p>異なる用途で同じ暗号プリミティブを使う場合、同じ鍵や同じドメイン分離を用いてはならないというのが、<br>
暗号に関する大原則である。ドメイン分離の例はまた出てくる。</p>
<section id="nistの指定するパラメータ" class="level4">
<h4 class="anchored" data-anchor-id="nistの指定するパラメータ">NISTの指定するパラメータ</h4>
<p>NISTはアルゴリズムのパラメータをビットで指定する。<br>
SHA-2もSHA-3も基本は、256ビット長を指定する。<br>
この制約を悪用した攻撃はビット攻撃という</p>
<p>鍵、パラメータ、出力という暗号文字列の長さはセキュリティ強度に大きく関係する。<br>
SHAKEでもcSHAKEでも短い出力は指定しない方がいい。<br>
256ビットを指定していれば安全(衝突攻撃に128ビットのセキュリティが確保できる)だが、<br>
色々の制約上、短い値を使わなければならないときは注意。<br>
短い値を使うプロトコルで衝突困難性に問題がないなら、<br>
現像計算困難性についてはSHAKE/cSHAKEから128ビットの出力でも良い(半分でもおk)</p>
</section>
</section>
<section id="tuplehashによるハッシュで曖昧さを回避する" class="level2">
<h2 class="anchored" data-anchor-id="tuplehashによるハッシュで曖昧さを回避する">2.5.4 TupleHashによるハッシュで曖昧さを回避する</h2>
<p>TupleHashはcSHAKEをベースにしている。タプルをハッシュできるのでTupleHash。</p>
<section id="どんなときに便利なのか" class="level3">
<h3 class="anchored" data-anchor-id="どんなときに便利なのか">どんなときに便利なのか？</h3>
<ul>
<li>著者の暗号通貨の精査の例
<ul>
<li>会計処理・決済など一般に求められる機能は備えている。</li>
<li>ユーザ間のトランザクションには、誰がいくら、誰に送ったかがわかるメタデータがある。
<ul>
<li>トランザクションネットワーク手数料も発生する。</li>
</ul></li>
</ul></li>
<li>アリスはネットワークにトランザクションを送信する
<ul>
<li>受け付けてもらうには送信元がアリスである証明も一緒に送る必要があるので、<br>
トランザクションをハッシュして署名する(<a href="https://8-u8.github.io/Real_World_Cryptography/chp01.html#%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E7%BD%B2%E5%90%8D-%E7%B4%99%E3%81%A8%E3%83%9A%E3%83%B3%E3%82%92%E4%BD%BF%E3%81%86%E7%BD%B2%E5%90%8D%E3%81%AB%E3%81%8B%E3%82%8F%E3%82%8B%E3%82%82%E3%81%AE">1章の例</a>を見よう)</li>
<li>誰でもこのトランザクションをハッシュできるし、ハッシュの署名の検証をすることができる。</li>
<li>中間者攻撃を試みても、ハッシュが変わってしまうので、改ざんされたトランザクションダイジェストは<br>
署名によって保証されず、改ざんが出来ない。</li>
</ul></li>
<li>筋が良さそうだが、「誰が」「誰に」「いくら」「手数料」を1つの文字列にしてハッシュしていた
<ul>
<li><code>AliceBob10015</code>という値をハッシュしていたとする。
<ul>
<li>「アリスがボブに100円、手数料15円で送金した」的なトランザクション。</li>
<li>「アリスがボブに1001円、手数料5円で送金した」とも読み取れ、こうしたとしてもハッシュ値は同じ。</li>
</ul></li>
<li>中間者がボブに金を受け取らせようとする場合、このようにすることも可能。やばい</li>
</ul></li>
<li>TupleHashはこれを<code>("Alice", "Bob", "100", "15")</code>というタプルの状態を維持したままハッシュ化できる。
<ul>
<li>ハッシュする前に入力をシリアライズ(順に並べる)する。</li>
<li>シリアライズには逆演算(デシリアライズ)が存在する。</li>
<li>フィールドの区切りに曖昧さをなくすことができる。</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="パスワードのハッシュ" class="level1">
<h1>2.6 パスワードのハッシュ</h1>
<ul>
<li>ZoomとかのURLで見る、<code>pwd=kofwokwkof</code>みたいな奴。
<ul>
<li>パスワードが平文で保存されている場合、漏洩すると大変
<ul>
<li>ユーザは基本パスワードを使いまわしていると思え。</li>
</ul></li>
</ul></li>
<li>パスワードをハッシュしてダイジェストだけを保存することが一つの解決策
<ol type="1">
<li>ユーザのパスワードを受け取る</li>
<li>受け取ったパスワードをハッシュして、ハッシュ値だけを残してパスワード平文は削除</li>
<li>ダイジェストを以前に保存したダイジェストと比較して、一致すればログインできる</li>
</ol></li>
<li>Webサイトのセキュリティは工場した
<ul>
<li>多層防御(defense in depth)とかいう。
<ul>
<li>不完全な防御層を重ねてすべてが破られないことを期待する</li>
</ul></li>
</ul></li>
<li>多層防御にも問題はある
<ol type="1">
<li>ハッシュしたパスワードが攻撃者の手に落ちると総当たり攻撃をやられるかもしれない。</li>
</ol>
<ul>
<li>ハッシュアルゴリズムは「公開」されているので、平文をハッシュ→一致を確認などをされる
<ul>
<li>ハッシュされたパスワードを1回あたり1つ以上を試せないようにしたほうが良い</li>
</ul></li>
<li>Saltを使って解決する。
<ul>
<li>ユーザに酔って異なる公開のランダム値。cSHAKEでユーザ別カスタマイズ文字列を使うことに似ている。</li>
<li>各ユーザに異なるハッシュ関数が作成される。</li>
<li>レインボーテーブルの事前計算によって、パスワードハッシュの全部を試すことは難しい</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>ハッシュ関数は高速を求められる。高速で計算できるということは、それだけ高速に様々なパスワードを実行できる</li>
</ol>
<ul>
<li>総当たり攻撃に対してハッシュ関数の計算速度が仇になる。</li>
<li>総当たり攻撃の実行そのものではなく、総当たり攻撃の試行を遅くするような取り組みがあると、対策はしやすいかもしれない。</li>
<li>低速になるように設計されたパスワードハッシュを使うこともできる。
<ul>
<li>Argon2。<a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-argon2/">RFCでの標準化</a>が進められている。</li>
<li><a href="https://password-hashing.net">コンペティション</a>はここ。</li>
<li>その他、PBKDF2/bcrypt/scryptなどのアルゴリズムもあるが、安全性の低いパラメータを指定する事ができるので、実際にプリミティブとして構成するのは難しい</li>
<li>現状、攻撃者からの最適化攻撃を防げるのはArgon2とscryptのみ。
<ul>
<li>メモリハード性を持つため。</li>
<li>メモリハード性: アルゴリズムがメモリアクセスの最適化以外で改善が見込まれないこと。
<ul>
<li>CPU周辺のキャッシュに上限があるので、専用のハードを用いてもこの改善は難しい(らしい)</li>
</ul></li>
<li>計算速度の遅さで殴る感じ。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>