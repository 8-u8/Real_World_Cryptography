<!-- title: 現代暗号技術入門のメモ・chp03 -->
[TOPへ戻る](https://8-u8.github.io/Real_World_Cryptography/)

# メッセージ認証コード
- データの完全性を保護する暗号プリミティブとしてMessage Authentication Code(MAC)が得られる(定義できる？)。
  - ハッシュ関数と秘密鍵を組み合わせることで定義される
- 秘密鍵の導入はどんなセキュリティでも基本的なもん。
  - 鍵がないと機密性を保証できず、認証も出来ないため。
  - ハッシュ関数は任意のデータについて真正性・完全性を保証する。
    - 裏では改ざんが出来ない、信頼性の高い「経路」の存在が大きい。
- MACを使用して信頼性の高い経路を設けることや、MACで実現できる機能をさらう。

# 3.1 ステートレスCookie、MACの導入となる例
- 自分がWebページであると想像しよう(！？)
  - いろいろなユーザが集まってくる
  - Webページである自分と対話(通信)するには、ログインに必要な資格情報(Credentials)を送ってもらい、検証する必要がある。最初の登録情報と一致すれば、ユーザの認証ができることになる
- Cookieは、何度も同じリクエストが発生することが想定される場合、都度認証を繰り返さずに済むように、ユーザの資格情報をブラウザに保存して、リクエストのたびに自動送信する。
  - Cookieは資格情報に限らず、ユーザに送信してほしい内容をなんでも保存できる。
  - セッションごとのCookieは、ユーザログイン直後に生成されるランダムな文字列を保持して、パスワードなどの秘密情報を平文で保存しないようにしている。
  - Cookieが漏洩しても、ユーザのパスワードに関する情報はもれない
    - ただし、攻撃者はユーザになりすます事ができる。

- サーバが増えた場合、ユーザとランダムな文字列の対応をすべてのサーバで共有するのは面倒(だし危険？)
  - ブラウザ側で保存する情報を増やすことで対応できる。
    - Cookieにランダムな文字列を保存せず、代わりにユーザ名を保存する
      - 平文で保存されると、ユーザ名の改ざんでなりすましができてしまう
      - ユーザ名をハッシュ化すると、改ざんした結果とハッシュ値が対応しなくなることが期待できるので、有効な手になりうる。
    - ユーザ名だけではなく、そのダイジェストもCookieに保存したい。
      - ハッシュの元を信頼できない場合、データの完全性は保証されない。
      - たとえば`bob|hash(bob)`というCookieを得られた場合、ハッシュ関数は公開されているので、`eve|hash(eve)`としてサーバへリクエストができてしまう。
  - MACはこうしたアプローチに対して良い答えを与えそう。

- MACは入力と秘密鍵をとる秘密鍵アルゴリズム
  - 入力と秘密鍵を使って認証タグを返す関数と考える。
  - 図3.3をプログラムにすると以下。

```python
auth_tag = MAC(x, secretkey) # MAC function is blackbox.
```

- 秘密鍵がないと、認証タグは生成出来ない。

- Cookieの改ざんを防ぐためにMACを使ってみる。
  - ブラウザ「`username: bob, pass:hunter2`」
    - 自分(Webサイト)「`Cookie: bob|mac(k, bob)`」
  - 悪意のある人「`eve|hogehoge`」
    - 自分(Webサイト)「認証タグが不正」
- 秘密鍵をもっている人でないと計算できない店で、プライベートなハッシュ関数に近い理解ができる。
  - ハッシュ関数からMACが作られることもある。


# 3.2 コードで見る実際の例
# 3.3 MACのセキュリティ特性
## 3.3.1 認証タグの捏造
## 3.3.2 認証タグの長さ
## 3.3.3 リプレイ攻撃
## 3.3.4 一定時間で認証タグを検証する
# 3.4 現実世界のMAC
## 3.4.1 メッセージの認証
## 3.4.2 鍵の導出
## 3.4.3 Cookieの完全性
## 3.4.4 ハッシュテーブル
# 3.5 メッセージ認証コード(MAC)の実際
## 3.5.1 HMAC: ハッシュベースのMAC
## 3.5.2 KMAC: cSHAKEベースのMAC
# 3.6 SHA-2と伸長攻撃